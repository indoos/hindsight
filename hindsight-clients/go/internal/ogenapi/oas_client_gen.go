// Code generated by ogen, DO NOT EDIT.

package ogenapi

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AddBankBackground invokes add_bank_background operation.
	//
	// Deprecated: Use PUT /mission instead. This endpoint now updates the mission field.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /v1/default/banks/{bank_id}/background
	AddBankBackground(ctx context.Context, request *AddBackgroundRequest, params AddBankBackgroundParams) (AddBankBackgroundRes, error)
	// CancelOperation invokes cancel_operation operation.
	//
	// Cancel a pending async operation by removing it from the queue.
	//
	// DELETE /v1/default/banks/{bank_id}/operations/{operation_id}
	CancelOperation(ctx context.Context, params CancelOperationParams) (CancelOperationRes, error)
	// ClearBankMemories invokes clear_bank_memories operation.
	//
	// Delete memory units for a memory bank. Optionally filter by type (world, experience, opinion) to
	// delete only specific types. This is a destructive operation that cannot be undone. The bank
	// profile (disposition and background) will be preserved.
	//
	// DELETE /v1/default/banks/{bank_id}/memories
	ClearBankMemories(ctx context.Context, params ClearBankMemoriesParams) (ClearBankMemoriesRes, error)
	// ClearObservations invokes clear_observations operation.
	//
	// Delete all observations for a memory bank. This is useful for resetting the consolidated knowledge.
	//
	// DELETE /v1/default/banks/{bank_id}/observations
	ClearObservations(ctx context.Context, params ClearObservationsParams) (ClearObservationsRes, error)
	// CreateDirective invokes create_directive operation.
	//
	// Create a hard rule that will be injected into prompts.
	//
	// POST /v1/default/banks/{bank_id}/directives
	CreateDirective(ctx context.Context, request *CreateDirectiveRequest, params CreateDirectiveParams) (CreateDirectiveRes, error)
	// CreateMentalModel invokes create_mental_model operation.
	//
	// Create a mental model by running reflect with the source query in the background. Returns an
	// operation ID to track progress. The content is auto-generated by the reflect endpoint. Use the
	// operations endpoint to check completion status.
	//
	// POST /v1/default/banks/{bank_id}/mental-models
	CreateMentalModel(ctx context.Context, request *CreateMentalModelRequest, params CreateMentalModelParams) (CreateMentalModelRes, error)
	// CreateOrUpdateBank invokes create_or_update_bank operation.
	//
	// Create a new agent or update existing agent with disposition and mission. Auto-fills missing
	// fields with defaults.
	//
	// PUT /v1/default/banks/{bank_id}
	CreateOrUpdateBank(ctx context.Context, request *CreateBankRequest, params CreateOrUpdateBankParams) (CreateOrUpdateBankRes, error)
	// DeleteBank invokes delete_bank operation.
	//
	// Delete an entire memory bank including all memories, entities, documents, and the bank profile
	// itself. This is a destructive operation that cannot be undone.
	//
	// DELETE /v1/default/banks/{bank_id}
	DeleteBank(ctx context.Context, params DeleteBankParams) (DeleteBankRes, error)
	// DeleteDirective invokes delete_directive operation.
	//
	// Delete a directive.
	//
	// DELETE /v1/default/banks/{bank_id}/directives/{directive_id}
	DeleteDirective(ctx context.Context, params DeleteDirectiveParams) (DeleteDirectiveRes, error)
	// DeleteDocument invokes delete_document operation.
	//
	// Delete a document and all its associated memory units and links.
	// This will cascade delete:
	// - The document itself
	// - All memory units extracted from this document
	// - All links (temporal, semantic, entity) associated with those memory units
	// This operation cannot be undone.
	//
	// DELETE /v1/default/banks/{bank_id}/documents/{document_id}
	DeleteDocument(ctx context.Context, params DeleteDocumentParams) (DeleteDocumentRes, error)
	// DeleteMentalModel invokes delete_mental_model operation.
	//
	// Delete a mental model.
	//
	// DELETE /v1/default/banks/{bank_id}/mental-models/{mental_model_id}
	DeleteMentalModel(ctx context.Context, params DeleteMentalModelParams) (DeleteMentalModelRes, error)
	// GetAgentStats invokes get_agent_stats operation.
	//
	// Get statistics about nodes and links for a specific agent.
	//
	// GET /v1/default/banks/{bank_id}/stats
	GetAgentStats(ctx context.Context, params GetAgentStatsParams) (GetAgentStatsRes, error)
	// GetBankConfig invokes get_bank_config operation.
	//
	// Get fully resolved configuration for a bank including all hierarchical overrides (global →
	// tenant → bank). The 'config' field contains all resolved config values. The 'overrides' field
	// shows only bank-specific overrides.
	//
	// GET /v1/default/banks/{bank_id}/config
	GetBankConfig(ctx context.Context, params GetBankConfigParams) (GetBankConfigRes, error)
	// GetBankProfile invokes get_bank_profile operation.
	//
	// Get disposition traits and mission for a memory bank. Auto-creates agent with defaults if not
	// exists.
	//
	// GET /v1/default/banks/{bank_id}/profile
	GetBankProfile(ctx context.Context, params GetBankProfileParams) (GetBankProfileRes, error)
	// GetChunk invokes get_chunk operation.
	//
	// Get a specific chunk by its ID.
	//
	// GET /v1/default/chunks/{chunk_id}
	GetChunk(ctx context.Context, params GetChunkParams) (GetChunkRes, error)
	// GetDirective invokes get_directive operation.
	//
	// Get a specific directive by ID.
	//
	// GET /v1/default/banks/{bank_id}/directives/{directive_id}
	GetDirective(ctx context.Context, params GetDirectiveParams) (GetDirectiveRes, error)
	// GetDocument invokes get_document operation.
	//
	// Get a specific document including its original text.
	//
	// GET /v1/default/banks/{bank_id}/documents/{document_id}
	GetDocument(ctx context.Context, params GetDocumentParams) (GetDocumentRes, error)
	// GetEntity invokes get_entity operation.
	//
	// Get detailed information about an entity including observations (mental model).
	//
	// GET /v1/default/banks/{bank_id}/entities/{entity_id}
	GetEntity(ctx context.Context, params GetEntityParams) (GetEntityRes, error)
	// GetGraph invokes get_graph operation.
	//
	// Retrieve graph data for visualization, optionally filtered by type (world/experience/opinion).
	//
	// GET /v1/default/banks/{bank_id}/graph
	GetGraph(ctx context.Context, params GetGraphParams) (GetGraphRes, error)
	// GetMemory invokes get_memory operation.
	//
	// Get a single memory unit by ID with all its metadata including entities and tags.
	//
	// GET /v1/default/banks/{bank_id}/memories/{memory_id}
	GetMemory(ctx context.Context, params GetMemoryParams) (GetMemoryRes, error)
	// GetMentalModel invokes get_mental_model operation.
	//
	// Get a specific mental model by ID.
	//
	// GET /v1/default/banks/{bank_id}/mental-models/{mental_model_id}
	GetMentalModel(ctx context.Context, params GetMentalModelParams) (GetMentalModelRes, error)
	// GetOperationStatus invokes get_operation_status operation.
	//
	// Get the status of a specific async operation. Returns 'pending', 'completed', or 'failed'.
	// Completed operations are removed from storage, so 'completed' means the operation finished
	// successfully.
	//
	// GET /v1/default/banks/{bank_id}/operations/{operation_id}
	GetOperationStatus(ctx context.Context, params GetOperationStatusParams) (GetOperationStatusRes, error)
	// GetVersion invokes get_version operation.
	//
	// Returns API version information and enabled feature flags. Use this to check which capabilities
	// are available in this deployment.
	//
	// GET /version
	GetVersion(ctx context.Context) (*VersionResponse, error)
	// HealthEndpointHealthGet invokes health_endpoint_health_get operation.
	//
	// Checks the health of the API and database connection.
	//
	// GET /health
	HealthEndpointHealthGet(ctx context.Context) (jx.Raw, error)
	// ListBanks invokes list_banks operation.
	//
	// Get a list of all agents with their profiles.
	//
	// GET /v1/default/banks
	ListBanks(ctx context.Context) (ListBanksRes, error)
	// ListDirectives invokes list_directives operation.
	//
	// List hard rules that are injected into prompts.
	//
	// GET /v1/default/banks/{bank_id}/directives
	ListDirectives(ctx context.Context, params ListDirectivesParams) (ListDirectivesRes, error)
	// ListDocuments invokes list_documents operation.
	//
	// List documents with pagination and optional search. Documents are the source content from which
	// memory units are extracted.
	//
	// GET /v1/default/banks/{bank_id}/documents
	ListDocuments(ctx context.Context, params ListDocumentsParams) (ListDocumentsRes, error)
	// ListEntities invokes list_entities operation.
	//
	// List all entities (people, organizations, etc.) known by the bank, ordered by mention count.
	// Supports pagination.
	//
	// GET /v1/default/banks/{bank_id}/entities
	ListEntities(ctx context.Context, params ListEntitiesParams) (ListEntitiesRes, error)
	// ListMemories invokes list_memories operation.
	//
	// List memory units with pagination and optional full-text search. Supports filtering by type.
	// Results are sorted by most recent first (mentioned_at DESC, then created_at DESC).
	//
	// GET /v1/default/banks/{bank_id}/memories/list
	ListMemories(ctx context.Context, params ListMemoriesParams) (ListMemoriesRes, error)
	// ListMentalModels invokes list_mental_models operation.
	//
	// List user-curated living documents that stay current.
	//
	// GET /v1/default/banks/{bank_id}/mental-models
	ListMentalModels(ctx context.Context, params ListMentalModelsParams) (ListMentalModelsRes, error)
	// ListOperations invokes list_operations operation.
	//
	// Get a list of async operations for a specific agent, with optional filtering by status. Results
	// are sorted by most recent first.
	//
	// GET /v1/default/banks/{bank_id}/operations
	ListOperations(ctx context.Context, params ListOperationsParams) (ListOperationsRes, error)
	// ListTags invokes list_tags operation.
	//
	// List all unique tags in a memory bank with usage counts. Supports wildcard search using '*' (e.g.,
	// 'user:*', '*-fred', 'tag*-2'). Case-insensitive.
	//
	// GET /v1/default/banks/{bank_id}/tags
	ListTags(ctx context.Context, params ListTagsParams) (ListTagsRes, error)
	// MetricsEndpointMetricsGet invokes metrics_endpoint_metrics_get operation.
	//
	// Exports metrics in Prometheus format for scraping.
	//
	// GET /metrics
	MetricsEndpointMetricsGet(ctx context.Context) (jx.Raw, error)
	// RecallMemories invokes recall_memories operation.
	//
	// Recall memory using semantic similarity and spreading activation.
	// The type parameter is optional and must be one of:
	// - `world`: General knowledge about people, places, events, and things that happen
	// - `experience`: Memories about experience, conversations, actions taken, and tasks performed.
	//
	// POST /v1/default/banks/{bank_id}/memories/recall
	RecallMemories(ctx context.Context, request *RecallRequest, params RecallMemoriesParams) (RecallMemoriesRes, error)
	// Reflect invokes reflect operation.
	//
	// Reflect and formulate an answer using bank identity, world facts, and opinions.
	// This endpoint:
	// 1. Retrieves experience (conversations and events)
	// 2. Retrieves world facts relevant to the query
	// 3. Retrieves existing opinions (bank's perspectives)
	// 4. Uses LLM to formulate a contextual answer
	// 5. Returns plain text answer and the facts used.
	//
	// POST /v1/default/banks/{bank_id}/reflect
	Reflect(ctx context.Context, request *ReflectRequest, params ReflectParams) (ReflectRes, error)
	// RefreshMentalModel invokes refresh_mental_model operation.
	//
	// Submit an async task to re-run the source query through reflect and update the content.
	//
	// POST /v1/default/banks/{bank_id}/mental-models/{mental_model_id}/refresh
	RefreshMentalModel(ctx context.Context, params RefreshMentalModelParams) (RefreshMentalModelRes, error)
	// RegenerateEntityObservations invokes regenerate_entity_observations operation.
	//
	// This endpoint is deprecated. Entity observations have been replaced by mental models.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /v1/default/banks/{bank_id}/entities/{entity_id}/regenerate
	RegenerateEntityObservations(ctx context.Context, params RegenerateEntityObservationsParams) (RegenerateEntityObservationsRes, error)
	// ResetBankConfig invokes reset_bank_config operation.
	//
	// Reset bank configuration to defaults by removing all bank-specific overrides. The bank will then
	// use global and tenant-level configuration only.
	//
	// DELETE /v1/default/banks/{bank_id}/config
	ResetBankConfig(ctx context.Context, params ResetBankConfigParams) (ResetBankConfigRes, error)
	// RetainMemories invokes retain_memories operation.
	//
	// Retain memory items with automatic fact extraction.
	// This is the main endpoint for storing memories. It supports both synchronous and asynchronous
	// processing via the `async` parameter.
	// **Features:**
	// - Efficient batch processing
	// - Automatic fact extraction from natural language
	// - Entity recognition and linking
	// - Document tracking with automatic upsert (when document_id is provided)
	// - Temporal and semantic linking
	// - Optional asynchronous processing
	// **The system automatically:**
	// 1. Extracts semantic facts from the content
	// 2. Generates embeddings
	// 3. Deduplicates similar facts
	// 4. Creates temporal, semantic, and entity links
	// 5. Tracks document metadata
	// **When `async=true`:** Returns immediately after queuing. Use the operations endpoint to monitor
	// progress.
	// **When `async=false` (default):** Waits for processing to complete.
	// **Note:** If a memory item has a `document_id` that already exists, the old document and its
	// memory units will be deleted before creating new ones (upsert behavior).
	//
	// POST /v1/default/banks/{bank_id}/memories
	RetainMemories(ctx context.Context, request *RetainRequest, params RetainMemoriesParams) (RetainMemoriesRes, error)
	// TriggerConsolidation invokes trigger_consolidation operation.
	//
	// Run memory consolidation to create/update observations from recent memories.
	//
	// POST /v1/default/banks/{bank_id}/consolidate
	TriggerConsolidation(ctx context.Context, params TriggerConsolidationParams) (TriggerConsolidationRes, error)
	// UpdateBank invokes update_bank operation.
	//
	// Partially update an agent's profile. Only provided fields will be updated.
	//
	// PATCH /v1/default/banks/{bank_id}
	UpdateBank(ctx context.Context, request *CreateBankRequest, params UpdateBankParams) (UpdateBankRes, error)
	// UpdateBankConfig invokes update_bank_config operation.
	//
	// Update configuration overrides for a bank. Only hierarchical fields can be overridden (LLM
	// settings, retention parameters, etc.). Keys can be provided in Python field format (llm_provider)
	// or environment variable format (HINDSIGHT_API_LLM_PROVIDER).
	//
	// PATCH /v1/default/banks/{bank_id}/config
	UpdateBankConfig(ctx context.Context, request *BankConfigUpdate, params UpdateBankConfigParams) (UpdateBankConfigRes, error)
	// UpdateBankDisposition invokes update_bank_disposition operation.
	//
	// Update bank's disposition traits (skepticism, literalism, empathy).
	//
	// PUT /v1/default/banks/{bank_id}/profile
	UpdateBankDisposition(ctx context.Context, request *UpdateDispositionRequest, params UpdateBankDispositionParams) (UpdateBankDispositionRes, error)
	// UpdateDirective invokes update_directive operation.
	//
	// Update a directive's properties.
	//
	// PATCH /v1/default/banks/{bank_id}/directives/{directive_id}
	UpdateDirective(ctx context.Context, request *UpdateDirectiveRequest, params UpdateDirectiveParams) (UpdateDirectiveRes, error)
	// UpdateMentalModel invokes update_mental_model operation.
	//
	// Update a mental model's name and/or source query.
	//
	// PATCH /v1/default/banks/{bank_id}/mental-models/{mental_model_id}
	UpdateMentalModel(ctx context.Context, request *UpdateMentalModelRequest, params UpdateMentalModelParams) (UpdateMentalModelRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AddBankBackground invokes add_bank_background operation.
//
// Deprecated: Use PUT /mission instead. This endpoint now updates the mission field.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /v1/default/banks/{bank_id}/background
func (c *Client) AddBankBackground(ctx context.Context, request *AddBackgroundRequest, params AddBankBackgroundParams) (AddBankBackgroundRes, error) {
	res, err := c.sendAddBankBackground(ctx, request, params)
	return res, err
}

func (c *Client) sendAddBankBackground(ctx context.Context, request *AddBackgroundRequest, params AddBankBackgroundParams) (res AddBankBackgroundRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/background"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddBankBackgroundRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddBankBackgroundResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CancelOperation invokes cancel_operation operation.
//
// Cancel a pending async operation by removing it from the queue.
//
// DELETE /v1/default/banks/{bank_id}/operations/{operation_id}
func (c *Client) CancelOperation(ctx context.Context, params CancelOperationParams) (CancelOperationRes, error) {
	res, err := c.sendCancelOperation(ctx, params)
	return res, err
}

func (c *Client) sendCancelOperation(ctx context.Context, params CancelOperationParams) (res CancelOperationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/operations/"
	{
		// Encode "operation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "operation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OperationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCancelOperationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ClearBankMemories invokes clear_bank_memories operation.
//
// Delete memory units for a memory bank. Optionally filter by type (world, experience, opinion) to
// delete only specific types. This is a destructive operation that cannot be undone. The bank
// profile (disposition and background) will be preserved.
//
// DELETE /v1/default/banks/{bank_id}/memories
func (c *Client) ClearBankMemories(ctx context.Context, params ClearBankMemoriesParams) (ClearBankMemoriesRes, error) {
	res, err := c.sendClearBankMemories(ctx, params)
	return res, err
}

func (c *Client) sendClearBankMemories(ctx context.Context, params ClearBankMemoriesParams) (res ClearBankMemoriesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/memories"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeClearBankMemoriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ClearObservations invokes clear_observations operation.
//
// Delete all observations for a memory bank. This is useful for resetting the consolidated knowledge.
//
// DELETE /v1/default/banks/{bank_id}/observations
func (c *Client) ClearObservations(ctx context.Context, params ClearObservationsParams) (ClearObservationsRes, error) {
	res, err := c.sendClearObservations(ctx, params)
	return res, err
}

func (c *Client) sendClearObservations(ctx context.Context, params ClearObservationsParams) (res ClearObservationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/observations"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeClearObservationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDirective invokes create_directive operation.
//
// Create a hard rule that will be injected into prompts.
//
// POST /v1/default/banks/{bank_id}/directives
func (c *Client) CreateDirective(ctx context.Context, request *CreateDirectiveRequest, params CreateDirectiveParams) (CreateDirectiveRes, error) {
	res, err := c.sendCreateDirective(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateDirective(ctx context.Context, request *CreateDirectiveRequest, params CreateDirectiveParams) (res CreateDirectiveRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/directives"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDirectiveRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateDirectiveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateMentalModel invokes create_mental_model operation.
//
// Create a mental model by running reflect with the source query in the background. Returns an
// operation ID to track progress. The content is auto-generated by the reflect endpoint. Use the
// operations endpoint to check completion status.
//
// POST /v1/default/banks/{bank_id}/mental-models
func (c *Client) CreateMentalModel(ctx context.Context, request *CreateMentalModelRequest, params CreateMentalModelParams) (CreateMentalModelRes, error) {
	res, err := c.sendCreateMentalModel(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateMentalModel(ctx context.Context, request *CreateMentalModelRequest, params CreateMentalModelParams) (res CreateMentalModelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/mental-models"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateMentalModelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateMentalModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateOrUpdateBank invokes create_or_update_bank operation.
//
// Create a new agent or update existing agent with disposition and mission. Auto-fills missing
// fields with defaults.
//
// PUT /v1/default/banks/{bank_id}
func (c *Client) CreateOrUpdateBank(ctx context.Context, request *CreateBankRequest, params CreateOrUpdateBankParams) (CreateOrUpdateBankRes, error) {
	res, err := c.sendCreateOrUpdateBank(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateOrUpdateBank(ctx context.Context, request *CreateBankRequest, params CreateOrUpdateBankParams) (res CreateOrUpdateBankRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateOrUpdateBankRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateOrUpdateBankResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteBank invokes delete_bank operation.
//
// Delete an entire memory bank including all memories, entities, documents, and the bank profile
// itself. This is a destructive operation that cannot be undone.
//
// DELETE /v1/default/banks/{bank_id}
func (c *Client) DeleteBank(ctx context.Context, params DeleteBankParams) (DeleteBankRes, error) {
	res, err := c.sendDeleteBank(ctx, params)
	return res, err
}

func (c *Client) sendDeleteBank(ctx context.Context, params DeleteBankParams) (res DeleteBankRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteBankResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDirective invokes delete_directive operation.
//
// Delete a directive.
//
// DELETE /v1/default/banks/{bank_id}/directives/{directive_id}
func (c *Client) DeleteDirective(ctx context.Context, params DeleteDirectiveParams) (DeleteDirectiveRes, error) {
	res, err := c.sendDeleteDirective(ctx, params)
	return res, err
}

func (c *Client) sendDeleteDirective(ctx context.Context, params DeleteDirectiveParams) (res DeleteDirectiveRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/directives/"
	{
		// Encode "directive_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "directive_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DirectiveID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteDirectiveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDocument invokes delete_document operation.
//
// Delete a document and all its associated memory units and links.
// This will cascade delete:
// - The document itself
// - All memory units extracted from this document
// - All links (temporal, semantic, entity) associated with those memory units
// This operation cannot be undone.
//
// DELETE /v1/default/banks/{bank_id}/documents/{document_id}
func (c *Client) DeleteDocument(ctx context.Context, params DeleteDocumentParams) (DeleteDocumentRes, error) {
	res, err := c.sendDeleteDocument(ctx, params)
	return res, err
}

func (c *Client) sendDeleteDocument(ctx context.Context, params DeleteDocumentParams) (res DeleteDocumentRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/documents/"
	{
		// Encode "document_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "document_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DocumentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteDocumentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteMentalModel invokes delete_mental_model operation.
//
// Delete a mental model.
//
// DELETE /v1/default/banks/{bank_id}/mental-models/{mental_model_id}
func (c *Client) DeleteMentalModel(ctx context.Context, params DeleteMentalModelParams) (DeleteMentalModelRes, error) {
	res, err := c.sendDeleteMentalModel(ctx, params)
	return res, err
}

func (c *Client) sendDeleteMentalModel(ctx context.Context, params DeleteMentalModelParams) (res DeleteMentalModelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/mental-models/"
	{
		// Encode "mental_model_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "mental_model_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MentalModelID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteMentalModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAgentStats invokes get_agent_stats operation.
//
// Get statistics about nodes and links for a specific agent.
//
// GET /v1/default/banks/{bank_id}/stats
func (c *Client) GetAgentStats(ctx context.Context, params GetAgentStatsParams) (GetAgentStatsRes, error) {
	res, err := c.sendGetAgentStats(ctx, params)
	return res, err
}

func (c *Client) sendGetAgentStats(ctx context.Context, params GetAgentStatsParams) (res GetAgentStatsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/stats"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAgentStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBankConfig invokes get_bank_config operation.
//
// Get fully resolved configuration for a bank including all hierarchical overrides (global →
// tenant → bank). The 'config' field contains all resolved config values. The 'overrides' field
// shows only bank-specific overrides.
//
// GET /v1/default/banks/{bank_id}/config
func (c *Client) GetBankConfig(ctx context.Context, params GetBankConfigParams) (GetBankConfigRes, error) {
	res, err := c.sendGetBankConfig(ctx, params)
	return res, err
}

func (c *Client) sendGetBankConfig(ctx context.Context, params GetBankConfigParams) (res GetBankConfigRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/config"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBankConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBankProfile invokes get_bank_profile operation.
//
// Get disposition traits and mission for a memory bank. Auto-creates agent with defaults if not
// exists.
//
// GET /v1/default/banks/{bank_id}/profile
func (c *Client) GetBankProfile(ctx context.Context, params GetBankProfileParams) (GetBankProfileRes, error) {
	res, err := c.sendGetBankProfile(ctx, params)
	return res, err
}

func (c *Client) sendGetBankProfile(ctx context.Context, params GetBankProfileParams) (res GetBankProfileRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/profile"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBankProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChunk invokes get_chunk operation.
//
// Get a specific chunk by its ID.
//
// GET /v1/default/chunks/{chunk_id}
func (c *Client) GetChunk(ctx context.Context, params GetChunkParams) (GetChunkRes, error) {
	res, err := c.sendGetChunk(ctx, params)
	return res, err
}

func (c *Client) sendGetChunk(ctx context.Context, params GetChunkParams) (res GetChunkRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/default/chunks/"
	{
		// Encode "chunk_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chunk_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChunkID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChunkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDirective invokes get_directive operation.
//
// Get a specific directive by ID.
//
// GET /v1/default/banks/{bank_id}/directives/{directive_id}
func (c *Client) GetDirective(ctx context.Context, params GetDirectiveParams) (GetDirectiveRes, error) {
	res, err := c.sendGetDirective(ctx, params)
	return res, err
}

func (c *Client) sendGetDirective(ctx context.Context, params GetDirectiveParams) (res GetDirectiveRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/directives/"
	{
		// Encode "directive_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "directive_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DirectiveID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDirectiveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDocument invokes get_document operation.
//
// Get a specific document including its original text.
//
// GET /v1/default/banks/{bank_id}/documents/{document_id}
func (c *Client) GetDocument(ctx context.Context, params GetDocumentParams) (GetDocumentRes, error) {
	res, err := c.sendGetDocument(ctx, params)
	return res, err
}

func (c *Client) sendGetDocument(ctx context.Context, params GetDocumentParams) (res GetDocumentRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/documents/"
	{
		// Encode "document_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "document_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DocumentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDocumentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEntity invokes get_entity operation.
//
// Get detailed information about an entity including observations (mental model).
//
// GET /v1/default/banks/{bank_id}/entities/{entity_id}
func (c *Client) GetEntity(ctx context.Context, params GetEntityParams) (GetEntityRes, error) {
	res, err := c.sendGetEntity(ctx, params)
	return res, err
}

func (c *Client) sendGetEntity(ctx context.Context, params GetEntityParams) (res GetEntityRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/entities/"
	{
		// Encode "entity_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "entity_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EntityID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEntityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGraph invokes get_graph operation.
//
// Retrieve graph data for visualization, optionally filtered by type (world/experience/opinion).
//
// GET /v1/default/banks/{bank_id}/graph
func (c *Client) GetGraph(ctx context.Context, params GetGraphParams) (GetGraphRes, error) {
	res, err := c.sendGetGraph(ctx, params)
	return res, err
}

func (c *Client) sendGetGraph(ctx context.Context, params GetGraphParams) (res GetGraphRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/graph"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetGraphResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMemory invokes get_memory operation.
//
// Get a single memory unit by ID with all its metadata including entities and tags.
//
// GET /v1/default/banks/{bank_id}/memories/{memory_id}
func (c *Client) GetMemory(ctx context.Context, params GetMemoryParams) (GetMemoryRes, error) {
	res, err := c.sendGetMemory(ctx, params)
	return res, err
}

func (c *Client) sendGetMemory(ctx context.Context, params GetMemoryParams) (res GetMemoryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/memories/"
	{
		// Encode "memory_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "memory_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MemoryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMemoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMentalModel invokes get_mental_model operation.
//
// Get a specific mental model by ID.
//
// GET /v1/default/banks/{bank_id}/mental-models/{mental_model_id}
func (c *Client) GetMentalModel(ctx context.Context, params GetMentalModelParams) (GetMentalModelRes, error) {
	res, err := c.sendGetMentalModel(ctx, params)
	return res, err
}

func (c *Client) sendGetMentalModel(ctx context.Context, params GetMentalModelParams) (res GetMentalModelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/mental-models/"
	{
		// Encode "mental_model_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "mental_model_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MentalModelID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMentalModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOperationStatus invokes get_operation_status operation.
//
// Get the status of a specific async operation. Returns 'pending', 'completed', or 'failed'.
// Completed operations are removed from storage, so 'completed' means the operation finished
// successfully.
//
// GET /v1/default/banks/{bank_id}/operations/{operation_id}
func (c *Client) GetOperationStatus(ctx context.Context, params GetOperationStatusParams) (GetOperationStatusRes, error) {
	res, err := c.sendGetOperationStatus(ctx, params)
	return res, err
}

func (c *Client) sendGetOperationStatus(ctx context.Context, params GetOperationStatusParams) (res GetOperationStatusRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/operations/"
	{
		// Encode "operation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "operation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OperationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetOperationStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVersion invokes get_version operation.
//
// Returns API version information and enabled feature flags. Use this to check which capabilities
// are available in this deployment.
//
// GET /version
func (c *Client) GetVersion(ctx context.Context) (*VersionResponse, error) {
	res, err := c.sendGetVersion(ctx)
	return res, err
}

func (c *Client) sendGetVersion(ctx context.Context) (res *VersionResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/version"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HealthEndpointHealthGet invokes health_endpoint_health_get operation.
//
// Checks the health of the API and database connection.
//
// GET /health
func (c *Client) HealthEndpointHealthGet(ctx context.Context) (jx.Raw, error) {
	res, err := c.sendHealthEndpointHealthGet(ctx)
	return res, err
}

func (c *Client) sendHealthEndpointHealthGet(ctx context.Context) (res jx.Raw, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHealthEndpointHealthGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListBanks invokes list_banks operation.
//
// Get a list of all agents with their profiles.
//
// GET /v1/default/banks
func (c *Client) ListBanks(ctx context.Context) (ListBanksRes, error) {
	res, err := c.sendListBanks(ctx)
	return res, err
}

func (c *Client) sendListBanks(ctx context.Context) (res ListBanksRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/default/banks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListBanksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListDirectives invokes list_directives operation.
//
// List hard rules that are injected into prompts.
//
// GET /v1/default/banks/{bank_id}/directives
func (c *Client) ListDirectives(ctx context.Context, params ListDirectivesParams) (ListDirectivesRes, error) {
	res, err := c.sendListDirectives(ctx, params)
	return res, err
}

func (c *Client) sendListDirectives(ctx context.Context, params ListDirectivesParams) (res ListDirectivesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/directives"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Tags != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Tags {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags_match" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags_match",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TagsMatch.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "active_only" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "active_only",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ActiveOnly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListDirectivesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListDocuments invokes list_documents operation.
//
// List documents with pagination and optional search. Documents are the source content from which
// memory units are extracted.
//
// GET /v1/default/banks/{bank_id}/documents
func (c *Client) ListDocuments(ctx context.Context, params ListDocumentsParams) (ListDocumentsRes, error) {
	res, err := c.sendListDocuments(ctx, params)
	return res, err
}

func (c *Client) sendListDocuments(ctx context.Context, params ListDocumentsParams) (res ListDocumentsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/documents"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "q" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Q.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListDocumentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListEntities invokes list_entities operation.
//
// List all entities (people, organizations, etc.) known by the bank, ordered by mention count.
// Supports pagination.
//
// GET /v1/default/banks/{bank_id}/entities
func (c *Client) ListEntities(ctx context.Context, params ListEntitiesParams) (ListEntitiesRes, error) {
	res, err := c.sendListEntities(ctx, params)
	return res, err
}

func (c *Client) sendListEntities(ctx context.Context, params ListEntitiesParams) (res ListEntitiesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/entities"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListEntitiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListMemories invokes list_memories operation.
//
// List memory units with pagination and optional full-text search. Supports filtering by type.
// Results are sorted by most recent first (mentioned_at DESC, then created_at DESC).
//
// GET /v1/default/banks/{bank_id}/memories/list
func (c *Client) ListMemories(ctx context.Context, params ListMemoriesParams) (ListMemoriesRes, error) {
	res, err := c.sendListMemories(ctx, params)
	return res, err
}

func (c *Client) sendListMemories(ctx context.Context, params ListMemoriesParams) (res ListMemoriesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/memories/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "q" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Q.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListMemoriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListMentalModels invokes list_mental_models operation.
//
// List user-curated living documents that stay current.
//
// GET /v1/default/banks/{bank_id}/mental-models
func (c *Client) ListMentalModels(ctx context.Context, params ListMentalModelsParams) (ListMentalModelsRes, error) {
	res, err := c.sendListMentalModels(ctx, params)
	return res, err
}

func (c *Client) sendListMentalModels(ctx context.Context, params ListMentalModelsParams) (res ListMentalModelsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/mental-models"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "tags" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Tags != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Tags {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tags_match" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tags_match",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TagsMatch.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListMentalModelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListOperations invokes list_operations operation.
//
// Get a list of async operations for a specific agent, with optional filtering by status. Results
// are sorted by most recent first.
//
// GET /v1/default/banks/{bank_id}/operations
func (c *Client) ListOperations(ctx context.Context, params ListOperationsParams) (ListOperationsRes, error) {
	res, err := c.sendListOperations(ctx, params)
	return res, err
}

func (c *Client) sendListOperations(ctx context.Context, params ListOperationsParams) (res ListOperationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/operations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListOperationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListTags invokes list_tags operation.
//
// List all unique tags in a memory bank with usage counts. Supports wildcard search using '*' (e.g.,
// 'user:*', '*-fred', 'tag*-2'). Case-insensitive.
//
// GET /v1/default/banks/{bank_id}/tags
func (c *Client) ListTags(ctx context.Context, params ListTagsParams) (ListTagsRes, error) {
	res, err := c.sendListTags(ctx, params)
	return res, err
}

func (c *Client) sendListTags(ctx context.Context, params ListTagsParams) (res ListTagsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "q" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Q.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MetricsEndpointMetricsGet invokes metrics_endpoint_metrics_get operation.
//
// Exports metrics in Prometheus format for scraping.
//
// GET /metrics
func (c *Client) MetricsEndpointMetricsGet(ctx context.Context) (jx.Raw, error) {
	res, err := c.sendMetricsEndpointMetricsGet(ctx)
	return res, err
}

func (c *Client) sendMetricsEndpointMetricsGet(ctx context.Context) (res jx.Raw, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/metrics"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMetricsEndpointMetricsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RecallMemories invokes recall_memories operation.
//
// Recall memory using semantic similarity and spreading activation.
// The type parameter is optional and must be one of:
// - `world`: General knowledge about people, places, events, and things that happen
// - `experience`: Memories about experience, conversations, actions taken, and tasks performed.
//
// POST /v1/default/banks/{bank_id}/memories/recall
func (c *Client) RecallMemories(ctx context.Context, request *RecallRequest, params RecallMemoriesParams) (RecallMemoriesRes, error) {
	res, err := c.sendRecallMemories(ctx, request, params)
	return res, err
}

func (c *Client) sendRecallMemories(ctx context.Context, request *RecallRequest, params RecallMemoriesParams) (res RecallMemoriesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/memories/recall"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRecallMemoriesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRecallMemoriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Reflect invokes reflect operation.
//
// Reflect and formulate an answer using bank identity, world facts, and opinions.
// This endpoint:
// 1. Retrieves experience (conversations and events)
// 2. Retrieves world facts relevant to the query
// 3. Retrieves existing opinions (bank's perspectives)
// 4. Uses LLM to formulate a contextual answer
// 5. Returns plain text answer and the facts used.
//
// POST /v1/default/banks/{bank_id}/reflect
func (c *Client) Reflect(ctx context.Context, request *ReflectRequest, params ReflectParams) (ReflectRes, error) {
	res, err := c.sendReflect(ctx, request, params)
	return res, err
}

func (c *Client) sendReflect(ctx context.Context, request *ReflectRequest, params ReflectParams) (res ReflectRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/reflect"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReflectRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReflectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RefreshMentalModel invokes refresh_mental_model operation.
//
// Submit an async task to re-run the source query through reflect and update the content.
//
// POST /v1/default/banks/{bank_id}/mental-models/{mental_model_id}/refresh
func (c *Client) RefreshMentalModel(ctx context.Context, params RefreshMentalModelParams) (RefreshMentalModelRes, error) {
	res, err := c.sendRefreshMentalModel(ctx, params)
	return res, err
}

func (c *Client) sendRefreshMentalModel(ctx context.Context, params RefreshMentalModelParams) (res RefreshMentalModelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/mental-models/"
	{
		// Encode "mental_model_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "mental_model_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MentalModelID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/refresh"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRefreshMentalModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RegenerateEntityObservations invokes regenerate_entity_observations operation.
//
// This endpoint is deprecated. Entity observations have been replaced by mental models.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /v1/default/banks/{bank_id}/entities/{entity_id}/regenerate
func (c *Client) RegenerateEntityObservations(ctx context.Context, params RegenerateEntityObservationsParams) (RegenerateEntityObservationsRes, error) {
	res, err := c.sendRegenerateEntityObservations(ctx, params)
	return res, err
}

func (c *Client) sendRegenerateEntityObservations(ctx context.Context, params RegenerateEntityObservationsParams) (res RegenerateEntityObservationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/entities/"
	{
		// Encode "entity_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "entity_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EntityID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/regenerate"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRegenerateEntityObservationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ResetBankConfig invokes reset_bank_config operation.
//
// Reset bank configuration to defaults by removing all bank-specific overrides. The bank will then
// use global and tenant-level configuration only.
//
// DELETE /v1/default/banks/{bank_id}/config
func (c *Client) ResetBankConfig(ctx context.Context, params ResetBankConfigParams) (ResetBankConfigRes, error) {
	res, err := c.sendResetBankConfig(ctx, params)
	return res, err
}

func (c *Client) sendResetBankConfig(ctx context.Context, params ResetBankConfigParams) (res ResetBankConfigRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/config"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeResetBankConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetainMemories invokes retain_memories operation.
//
// Retain memory items with automatic fact extraction.
// This is the main endpoint for storing memories. It supports both synchronous and asynchronous
// processing via the `async` parameter.
// **Features:**
// - Efficient batch processing
// - Automatic fact extraction from natural language
// - Entity recognition and linking
// - Document tracking with automatic upsert (when document_id is provided)
// - Temporal and semantic linking
// - Optional asynchronous processing
// **The system automatically:**
// 1. Extracts semantic facts from the content
// 2. Generates embeddings
// 3. Deduplicates similar facts
// 4. Creates temporal, semantic, and entity links
// 5. Tracks document metadata
// **When `async=true`:** Returns immediately after queuing. Use the operations endpoint to monitor
// progress.
// **When `async=false` (default):** Waits for processing to complete.
// **Note:** If a memory item has a `document_id` that already exists, the old document and its
// memory units will be deleted before creating new ones (upsert behavior).
//
// POST /v1/default/banks/{bank_id}/memories
func (c *Client) RetainMemories(ctx context.Context, request *RetainRequest, params RetainMemoriesParams) (RetainMemoriesRes, error) {
	res, err := c.sendRetainMemories(ctx, request, params)
	return res, err
}

func (c *Client) sendRetainMemories(ctx context.Context, request *RetainRequest, params RetainMemoriesParams) (res RetainMemoriesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/memories"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRetainMemoriesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRetainMemoriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TriggerConsolidation invokes trigger_consolidation operation.
//
// Run memory consolidation to create/update observations from recent memories.
//
// POST /v1/default/banks/{bank_id}/consolidate
func (c *Client) TriggerConsolidation(ctx context.Context, params TriggerConsolidationParams) (TriggerConsolidationRes, error) {
	res, err := c.sendTriggerConsolidation(ctx, params)
	return res, err
}

func (c *Client) sendTriggerConsolidation(ctx context.Context, params TriggerConsolidationParams) (res TriggerConsolidationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/consolidate"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTriggerConsolidationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateBank invokes update_bank operation.
//
// Partially update an agent's profile. Only provided fields will be updated.
//
// PATCH /v1/default/banks/{bank_id}
func (c *Client) UpdateBank(ctx context.Context, request *CreateBankRequest, params UpdateBankParams) (UpdateBankRes, error) {
	res, err := c.sendUpdateBank(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateBank(ctx context.Context, request *CreateBankRequest, params UpdateBankParams) (res UpdateBankRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateBankRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateBankResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateBankConfig invokes update_bank_config operation.
//
// Update configuration overrides for a bank. Only hierarchical fields can be overridden (LLM
// settings, retention parameters, etc.). Keys can be provided in Python field format (llm_provider)
// or environment variable format (HINDSIGHT_API_LLM_PROVIDER).
//
// PATCH /v1/default/banks/{bank_id}/config
func (c *Client) UpdateBankConfig(ctx context.Context, request *BankConfigUpdate, params UpdateBankConfigParams) (UpdateBankConfigRes, error) {
	res, err := c.sendUpdateBankConfig(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateBankConfig(ctx context.Context, request *BankConfigUpdate, params UpdateBankConfigParams) (res UpdateBankConfigRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/config"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateBankConfigRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateBankConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateBankDisposition invokes update_bank_disposition operation.
//
// Update bank's disposition traits (skepticism, literalism, empathy).
//
// PUT /v1/default/banks/{bank_id}/profile
func (c *Client) UpdateBankDisposition(ctx context.Context, request *UpdateDispositionRequest, params UpdateBankDispositionParams) (UpdateBankDispositionRes, error) {
	res, err := c.sendUpdateBankDisposition(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateBankDisposition(ctx context.Context, request *UpdateDispositionRequest, params UpdateBankDispositionParams) (res UpdateBankDispositionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/profile"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateBankDispositionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateBankDispositionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateDirective invokes update_directive operation.
//
// Update a directive's properties.
//
// PATCH /v1/default/banks/{bank_id}/directives/{directive_id}
func (c *Client) UpdateDirective(ctx context.Context, request *UpdateDirectiveRequest, params UpdateDirectiveParams) (UpdateDirectiveRes, error) {
	res, err := c.sendUpdateDirective(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateDirective(ctx context.Context, request *UpdateDirectiveRequest, params UpdateDirectiveParams) (res UpdateDirectiveRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/directives/"
	{
		// Encode "directive_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "directive_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DirectiveID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateDirectiveRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateDirectiveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateMentalModel invokes update_mental_model operation.
//
// Update a mental model's name and/or source query.
//
// PATCH /v1/default/banks/{bank_id}/mental-models/{mental_model_id}
func (c *Client) UpdateMentalModel(ctx context.Context, request *UpdateMentalModelRequest, params UpdateMentalModelParams) (UpdateMentalModelRes, error) {
	res, err := c.sendUpdateMentalModel(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateMentalModel(ctx context.Context, request *UpdateMentalModelRequest, params UpdateMentalModelParams) (res UpdateMentalModelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/default/banks/"
	{
		// Encode "bank_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bank_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/mental-models/"
	{
		// Encode "mental_model_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "mental_model_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MentalModelID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateMentalModelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateMentalModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
